KCPSM6 Assembler log file for program 'D:\Xilinx_projects\USC_Keypad\Keypad_5RO_6WO_ports\assembly\prom_kypd_5RO_6WO.psm'.
Generated by KCPSM6 version v2.70
Ken Chapman - Xilinx Ltd - 16th May 2014

Assembly datestamp: 21 Mar 2020
Assembly timestamp: 19:52:10

Contents
  Assembly listing
  List of PSM files
  List of CONSTANTs
  List of TABLEs
  List of STRINGs
  List of line labels
  Instruction usage statistics


Last occupied address: 087 hex
Nominal program memory size: 1K (1024)   address(9:0)
Actual memory size: 4096
  (Default memory size)
Occupied memory locations: 136
Memory locations available: 3960


Assembly listing

 Addr Code                  Instruction

 000                        ; KCPSM6 Program
 000                        ; This program reads row inputs through one input (row_col_port) port
 000                        ; Last 4 bits represent row inputs
 000                        ; One input port (Switch) is used to read switch input
 000                        ; One output port(row_col_port) is used to drive 4 column outputs
 000                        ; One output port(Anode) drives the anode value
 000                        ; Another output port (SSD_out) sends the value to be displayed
 000                        ; KCPSM6 Program
 000                        ; prom_kypd_5RO_6WO.psm (solution)
 000                        ; keypad interface using picoblaze
 000                        ; 10/20/2017 Designed by: Shashidhar Aravind Kulkarni <shashidk@usc.edu> and Gandhi Puvvada <gandhi@usc.edu>
 000                        ; 3/9/2020  Ported to Nexys-4 by "Yue (Julien) Niu" <yueniu@usc.edu> and Gandhi Puvvada <gandhi@usc.edu>
 000                        ;
 000                        ; ======
 000                        ; Parts of our solution code is removed and we marked such portions with a "TODO" for your to complete.
 000                        ; Complete the      TODO sections to complete this .psm file.
 000                        ; ======
 000                        ; The key pressed on the hex keypad is detected and is displayed on 0 to 4 SSDs
 000                        ; based on how many of the 4 switches (SW3 to SW0) are set to ON position.
 000                        ;
 000                        ; Dealys in Key detection part:
 000                        ; We wait for COL_DRV_DELAY time of DELAY_1MS (about 1 millisecond = 100,000 of 10ns clocks
 000                        ; and drive the columns and then
 000                        ; wait for about ROW_CHK_DELAY of about 100x4 clocks
 000                        ; and read thhe rows and check.
 000                        ; We do not support multiple key operation at the same time.
 000                        ; Interface with the hardware:
 000                        ; This program writes to 4 output ports (port_ids  00, 01, 02, 03 hex, symbolic names: row0_col0 row1_col1 row2_col2 row3_col3)
 000                        ; to drive the four column outputs (going to the keypad) with one-cold combination.
 000                        ; The same port_ids are used for the input ports to read the row inputs (coming from the keypad) one row at a time!
 000                        ; There is no conflict in using the same port_ids for both (an input port and an output port).
 000                        ; Column data is sent on out_port[0] and row data is received on in_port[0].
 000                        ; port-id = 04 hex (symbolic name = Switch_Anode) is shared between
 000                        ; an input port to read 4 switches (SW3-SW0) and
 000                        ; an output port to drive 4 anodes (for the 4 SSDs).
 000                        ; INPUT  s5, Switch_Anode ;
 000                        ; OUTPUT s5, Switch_Anode ;
 000                        ; One more port_id = 05 hex (symbolic name = SSD_out) is used for
 000                        ; an output port to send 7 segment data to be displayed on the SSD(s).
 000                        ; OUTPUT s5, SSD_out ;
 000                        ;**************************************************************************************
 000                        ;Port definitions
 000                        ;**************************************************************************************
 000                        CONSTANT row0_col0, 00      ; port 0 for input of row0 and output of col0
 000                        CONSTANT row1_col1, 01      ; port 1 for input of row1 and output of col1
 000                        CONSTANT row2_col2, 02      ; port 2 for input of row2 and output of col2 <== TODO #1
 000                        CONSTANT row3_col3, 03      ; port 3 for input of row3 and output of col3
 000                        CONSTANT Switch_Anode, 04   ; port 4 for input of switches and output of anode
 000                        CONSTANT SSD_out, 05        ; port 5 for output of SSD
 000                        ;**************************************************************************************
 000                        ;Mask definitions
 000                        ;**************************************************************************************
 000                        CONSTANT Mask0111, 07       ; to check if row 0 is low 7 = 0111
 000                        CONSTANT Mask1011, 0B       ; to check if row 1 is low B = 1011
 000                        CONSTANT Mask1101, 0D       ; to check if row 2 is low D = 1101
 000                        CONSTANT Mask1110, 0E       ; to check if row 3 is low E = 1110
 000                        ;**************************************************************************************
 000                        ;SSD Cathode definitions
 000                        ;**************************************************************************************
 000                        CONSTANT Display0, 40       ; code to display 0 on SSD
 000                        CONSTANT Display1, 79       ; code to display 1 on SSD
 000                        CONSTANT Display2, 24       ; code to display 2 on SSD
 000                        CONSTANT Display3, 30       ; code to display 3 on SSD
 000                        CONSTANT Display4, 19       ; code to display 4 on SSD
 000                        CONSTANT Display5, 12       ; code to display 5 on SSD
 000                        CONSTANT Display6, 02       ; code to display 6 on SSD
 000                        CONSTANT Display7, 78       ; code to display 7 on SSD
 000                        CONSTANT Display8, 00       ; code to display 8 on SSD
 000                        CONSTANT Display9, 10       ; code to display 9 on SSD
 000                        CONSTANT DisplayA, 08       ; code to display A on SSD
 000                        CONSTANT DisplayB, 03       ; code to display B on SSD
 000                        CONSTANT DisplayC, 46       ; code to display C on SSD
 000                        CONSTANT DisplayD, 21       ; code to display D on SSD
 000                        CONSTANT DisplayE, 06       ; code to display E on SSD
 000                        CONSTANT DisplayF, 0E       ; code to display F on SSD
 000                        ;**************************************************************************************
 000                        ;MAIN PROGRAM
 000                        ;**************************************************************************************
 000  01164          START: LOAD s1, 64[100'd]          ; s1 is used to wait for 100*4 clocks after driving column
 001  012FE                 LOAD s2, FE                 ; to send make only last bit as 0 to the col output (to a single line column output)
 002  013FF                 LOAD s3, FF                 ; to send all 1's to the unselected col output
 003  09504       COL0_OUT: INPUT s5, 04[Switch_Anode]  ; read the switches
 004  075FF                 XOR s5, FF                  ; to send to anodes based on switches -- please understand the XOR operation
 005  2D504                 OUTPUT s5, 04[Switch_Anode] ; ; send anode value to use SSD
 006  2006F                 CALL 06F[DELAY_1MS]         ;
 007  2D200                 OUTPUT s2, 00[row0_col0]    ; drive column 0 to 0 <== TODO #2
 008  2D301                 OUTPUT s3, 01[row1_col1]    ; drive column 1 to 1
 009  2D302                 OUTPUT s3, 02[row2_col2]    ; drive column 2 to 1
 00A  2D303                 OUTPUT s3, 03[row3_col3]    ; drive column 3 to 1
 00B  20078                 CALL 078[ROW_CHK_DELAY]     ;
 00C  2007C    ROW_CHECK00: CALL 07C[READ_ROWS]         ; start checking rows
 00D  1D407                 COMPARE s4, 07[Mask0111]    ; check if the row0 is 0 and others are 1 (0111)
 00E  36012                 JUMP NZ, 012[ROW_CHECK01]   ; Jump to next row checking if row0 is not 0
 00F  01579                 LOAD s5, 79[Display1]       ; Load  to display 1
 010  2D505                 OUTPUT s5, 05[SSD_out]      ; Send value to be displayed on SSD
 011  22020                 JUMP 020[COL1_OUT]          ; Go to next column driving
 012  1D40B    ROW_CHECK01: COMPARE s4, 0B[Mask1011]    ; check if the row1 is 0 and others are 1 (1011)
 013  36017                 JUMP NZ, 017[ROW_CHECK02]   ; Jump to next row checking if row1 is not 0
 014  01519                 LOAD s5, 19[Display4]       ; Load to display 4
 015  2D505                 OUTPUT s5, 05[SSD_out]      ; Send value to be displayed on SSD
 016  22020                 JUMP 020[COL1_OUT]          ; Go to next column driving
 017  1D40D    ROW_CHECK02: COMPARE s4, 0D[Mask1101]    ; check if the row2 is 0 and others are 1 (1101)
 018  3601C                 JUMP NZ, 01C[ROW_CHECK03]   ; Jump to next row checking if row2 is not 0
 019  01578                 LOAD s5, 78[Display7]       ; Load to display 7
 01A  2D505                 OUTPUT s5, 05[SSD_out]      ; Send value to be displayed on SSD
 01B  22020                 JUMP 020[COL1_OUT]          ; Go to next column driving
 01C  1D40E    ROW_CHECK03: COMPARE s4, 0E[Mask1110]    ; check if the row3 is 0 and others are 1 (1110)
 01D  36020                 JUMP NZ, 020[COL1_OUT]      ; Jump to next column driving if row3 is not 0
 01E  01540                 LOAD s5, 40[Display0]       ; Load to display 0
 01F  2D505                 OUTPUT s5, 05[SSD_out]      ; Send value to be displayed on SSD
 020  2006F       COL1_OUT: CALL 06F[DELAY_1MS]         ;
 021  2D300                 OUTPUT s3, 00[row0_col0]    ; drive column 0 to 1 <== TODO #3
 022  2D201                 OUTPUT s2, 01[row1_col1]    ; drive column 1 to 0
 023  2D302                 OUTPUT s3, 02[row2_col2]    ; drive column 2 to 1
 024  2D303                 OUTPUT s3, 03[row3_col3]    ; drive column 3 to 1
 025  20078                 CALL 078[ROW_CHK_DELAY]     ;
 026  2007C    ROW_CHECK10: CALL 07C[READ_ROWS]         ; start checking rows
 027  1D407                 COMPARE s4, 07[Mask0111]    ; check if the row0 is 0 and others are 1 (0111)
 028  3602C                 JUMP NZ, 02C[ROW_CHECK11]   ; Jump to next row checking if row0 is not 0
 029  01524                 LOAD s5, 24[Display2]       ; Load to display 2
 02A  2D505                 OUTPUT s5, 05[SSD_out]      ; Send value to be displayed on SSD
 02B  2203A                 JUMP 03A[COL2_OUT]          ; Go to next column driving
 02C  1D40B    ROW_CHECK11: COMPARE s4, 0B[Mask1011]    ; check if the row1 is 0 and others are 1 (1011)
 02D  36031                 JUMP NZ, 031[ROW_CHECK12]   ; Jump to next row checking if row1 is not 0
 02E  01512                 LOAD s5, 12[Display5]       ; Load to display 5
 02F  2D505                 OUTPUT s5, 05[SSD_out]      ; Send value to be displayed on SSD
 030  2203A                 JUMP 03A[COL2_OUT]          ; Go to next column driving
 031  1D40D    ROW_CHECK12: COMPARE s4, 0D[Mask1101]    ; <== copy the code from part1
 032  36036                 JUMP NZ, 036[ROW_CHECK13]   ; Jump to next row checking if row2 is not 0
 033  01500                 LOAD s5, 00[Display8]       ; Load to display 8
 034  2D505                 OUTPUT s5, 05[SSD_out]      ; Send value to be displayed on SSD
 035  2203A                 JUMP 03A[COL2_OUT]          ; Go to next column driving
 036  1D40E    ROW_CHECK13: COMPARE s4, 0E[Mask1110]    ; <== copy the code from part1
 037  3603A                 JUMP NZ, 03A[COL2_OUT]      ; Jump to next column driving if row3 is not 0
 038  0150E                 LOAD s5, 0E[DisplayF]       ; Load to display F
 039  2D505                 OUTPUT s5, 05[SSD_out]      ; Send value to be displayed on SSD
 03A  2006F       COL2_OUT: CALL 06F[DELAY_1MS]         ;
 03B  2D300                 OUTPUT s3, 00[row0_col0]    ; drive column 0 to 1 <<== TODO #4
 03C  2D301                 OUTPUT s3, 01[row1_col1]    ; drive column 1 to 1
 03D  2D202                 OUTPUT s2, 02[row2_col2]    ; drive column 2 to 0
 03E  2D303                 OUTPUT s3, 03[row3_col3]    ; drive column 3 to 1
 03F  20078                 CALL 078[ROW_CHK_DELAY]     ;
 040  2007C    ROW_CHECK20: CALL 07C[READ_ROWS]         ; start checking rows
 041  1D407                 COMPARE s4, 07[Mask0111]    ; check if the row0 is 0 and others are 1 (0111)
 042  36046                 JUMP NZ, 046[ROW_CHECK21]   ; Jump to next row checking if row0 is not 0
 043  01530                 LOAD s5, 30[Display3]       ; Load  to display 3
 044  2D505                 OUTPUT s5, 05[SSD_out]      ; Send value to be displayed on SSD
 045  22054                 JUMP 054[COL3_OUT]          ; Go to next column driving
 046  1D40B    ROW_CHECK21: COMPARE s4, 0B[Mask1011]    ; check if the row1 is 0 and others are 1 (1011)
 047  3604B                 JUMP NZ, 04B[ROW_CHECK22]   ; Jump to next row checking if row1 is not 0
 048  01502                 LOAD s5, 02[Display6]       ; Load to display 6
 049  2D505                 OUTPUT s5, 05[SSD_out]      ; Send value to be displayed on SSD
 04A  22054                 JUMP 054[COL3_OUT]          ; Go to next column driving
 04B  1D40D    ROW_CHECK22: COMPARE s4, 0D[Mask1101]    ; check if the row2 is 0 and others are 1 (1101)
 04C  36050                 JUMP NZ, 050[ROW_CHECK23]   ; Jump to next row checking if row2 is not 0
 04D  01510                 LOAD s5, 10[Display9]       ; Load to display 9
 04E  2D505                 OUTPUT s5, 05[SSD_out]      ; Send value to be displayed on SSD
 04F  22054                 JUMP 054[COL3_OUT]          ; Go to next column driving
 050  1D40E    ROW_CHECK23: COMPARE s4, 0E[Mask1110]    ; check if the row3 is 0 and others are 1 (1110)
 051  36054                 JUMP NZ, 054[COL3_OUT]      ; Jump to next column driving if row3 is not 0
 052  01506                 LOAD s5, 06[DisplayE]       ; Load to display E
 053  2D505                 OUTPUT s5, 05[SSD_out]      ; Send value to be displayed on SSD
 054  2006F       COL3_OUT: CALL 06F[DELAY_1MS]         ;
 055  2D300                 OUTPUT s3, 00[row0_col0]    ; drive column 0 to 1 <== TODO #5
 056  2D301                 OUTPUT s3, 01[row1_col1]    ; drive column 1 to 1
 057  2D302                 OUTPUT s3, 02[row2_col2]    ; drive column 2 to 1
 058  2D203                 OUTPUT s2, 03[row3_col3]    ; drive column 3 to 0
 059  20078                 CALL 078[ROW_CHK_DELAY]     ;
 05A  2007C    ROW_CHECK30: CALL 07C[READ_ROWS]         ; start checking rows
 05B  1D407                 COMPARE s4, 07[Mask0111]    ; check if the row0 is 0 and others are 1 (0111)
 05C  36060                 JUMP NZ, 060[ROW_CHECK31]   ; Jump to next row checking if row0 is not 0
 05D  01508                 LOAD s5, 08[DisplayA]       ; Load to display A
 05E  2D505                 OUTPUT s5, 05[SSD_out]      ; Send value to be displayed on SSD
 05F  22003                 JUMP 003[COL0_OUT]          ; Go to next column driving
 060  1D40B    ROW_CHECK31: COMPARE s4, 0B[Mask1011]    ; check if the row1 is 0 and others are 1 (1011)
 061  36065                 JUMP NZ, 065[ROW_CHECK32]   ; Jump to next row checking if row1 is not 0
 062  01503                 LOAD s5, 03[DisplayB]       ; Load to display B
 063  2D505                 OUTPUT s5, 05[SSD_out]      ; Send value to be displayed on SSD
 064  22003                 JUMP 003[COL0_OUT]          ; Jump to column 0 driving
 065  1D40D    ROW_CHECK32: COMPARE s4, 0D[Mask1101]    ; check if the row2 is 0 and others are 1 (1101)
 066  3606A                 JUMP NZ, 06A[ROW_CHECK33]   ; Jump to next row checking if row2 is not 0
 067  01546                 LOAD s5, 46[DisplayC]       ; Load to display C
 068  2D505                 OUTPUT s5, 05[SSD_out]      ; Send value to be displayed on SSD
 069  22003                 JUMP 003[COL0_OUT]          ; Jump to column 0 driving
 06A  1D40E    ROW_CHECK33: COMPARE s4, 0E[Mask1110]    ; <== copy the code from part1
 06B  36003                 JUMP NZ, 003[COL0_OUT]      ; Jump to next column driving if row3 is not 0
 06C  01521                 LOAD s5, 21[DisplayD]       ; Load to display D
 06D  2D505                 OUTPUT s5, 05[SSD_out]      ; Send value to be displayed on SSD
 06E  22003                 JUMP 003[COL0_OUT]          ; Jump to column 0 driving
 06F                        ; subroutine to wait for driving column
 06F  01A00      DELAY_1MS: LOAD sA, 00
 070  01927                 LOAD s9, 27
 071  01810                 LOAD s8, 10                 ; s8, s9, sA are used to generate 1ms software delay
 072  00880     SOFT_DELAY: LOAD s8, s8                 ; pad loop to make it 10 clock cycles (5 instructions)
 073  19801                 SUB s8, 01[1'd]
 074  1B900                 SUBCY s9, 00[0'd]
 075  1BA00                 SUBCY sA, 00[0'd]
 076  36072                 JUMP NZ, 072[SOFT_DELAY]    ;
 077  25000                 RETURN                      ;
 078                        ; subroutine to wait for checking row  ; <== copy the code from part1
 078  19101  ROW_CHK_DELAY: SUB s1, 01[1'd]             ; wait for 100*4 clocks (we did previously  LOAD s1, 100'd )
 079  36078                 JUMP NZ, 078[ROW_CHK_DELAY] ;
 07A  01164                 LOAD s1, 64[100'd]          ;
 07B  25000                 RETURN                      ; load the count value to be used in next row check
 07C                        ; read input rows <== TODO #6
 07C  09000      READ_ROWS: INPUT s0, 00[row0_col0]
 07D  00400                 LOAD s4, s0                 ; s4 stores concatenated values along rows
 07E  09001                 INPUT s0, 01[row1_col1]
 07F  14406                 SL0 s4
 080  04400                 OR s4, s0                   ; concatenate inputs
 081  09002                 INPUT s0, 02[row2_col2]
 082  14406                 SL0 s4
 083  04400                 OR s4, s0                   ; concatenate inputs
 084  09003                 INPUT s0, 03[row3_col3]
 085  14406                 SL0 s4
 086  04400                 OR s4, s0                   ; concatenate inputs
 087  25000                 RETURN 


All unused memory locations contain zero (equivalent to 'LOAD s0, s0')



List of PSM files that have been assembled

D:\Xilinx_projects\USC_Keypad\Keypad_5RO_6WO_ports\assembly\prom_kypd_5RO_6WO.psm



List of defined constants

 CONSTANT name     Value        Source PSM File

 timestamp_hours   19'd         
 timestamp_minutes 52'd         
 timestamp_seconds 10'd         
 datestamp_year    20'd         
 datestamp_month   3'd          
 datestamp_day     21'd         
 NUL               00           
 BEL               07           
 BS                08           
 HT                09           
 LF                0A           
 VT                0B           
 CR                0D           
 ESC               1B           
 DEL               7F           
 DCS               90           
 ST                9C           
 row0_col0         00           prom_kypd_5RO_6WO.psm
 row1_col1         01           prom_kypd_5RO_6WO.psm
 row2_col2         02           prom_kypd_5RO_6WO.psm
 row3_col3         03           prom_kypd_5RO_6WO.psm
 Switch_Anode      04           prom_kypd_5RO_6WO.psm
 SSD_out           05           prom_kypd_5RO_6WO.psm
 Mask0111          07           prom_kypd_5RO_6WO.psm
 Mask1011          0B           prom_kypd_5RO_6WO.psm
 Mask1101          0D           prom_kypd_5RO_6WO.psm
 Mask1110          0E           prom_kypd_5RO_6WO.psm
 Display0          40           prom_kypd_5RO_6WO.psm
 Display1          79           prom_kypd_5RO_6WO.psm
 Display2          24           prom_kypd_5RO_6WO.psm
 Display3          30           prom_kypd_5RO_6WO.psm
 Display4          19           prom_kypd_5RO_6WO.psm
 Display5          12           prom_kypd_5RO_6WO.psm
 Display6          02           prom_kypd_5RO_6WO.psm
 Display7          78           prom_kypd_5RO_6WO.psm
 Display8          00           prom_kypd_5RO_6WO.psm
 Display9          10           prom_kypd_5RO_6WO.psm
 DisplayA          08           prom_kypd_5RO_6WO.psm
 DisplayB          03           prom_kypd_5RO_6WO.psm
 DisplayC          46           prom_kypd_5RO_6WO.psm
 DisplayD          21           prom_kypd_5RO_6WO.psm
 DisplayE          06           prom_kypd_5RO_6WO.psm
 DisplayF          0E           prom_kypd_5RO_6WO.psm



No TABLEs defined



List of text strings

 STRING name       String         Source PSM File

 KCPSM6_version$   "v2.70"        
 datestamp$        "21 Mar 2020"  
 timestamp$        "19:52:10"     



List of line labels

   Label           Addr  Source PSM File

 * START           000   prom_kypd_5RO_6WO.psm
   COL0_OUT        003   prom_kypd_5RO_6WO.psm
 * ROW_CHECK00     00C   prom_kypd_5RO_6WO.psm
   ROW_CHECK01     012   prom_kypd_5RO_6WO.psm
   ROW_CHECK02     017   prom_kypd_5RO_6WO.psm
   ROW_CHECK03     01C   prom_kypd_5RO_6WO.psm
   COL1_OUT        020   prom_kypd_5RO_6WO.psm
 * ROW_CHECK10     026   prom_kypd_5RO_6WO.psm
   ROW_CHECK11     02C   prom_kypd_5RO_6WO.psm
   ROW_CHECK12     031   prom_kypd_5RO_6WO.psm
   ROW_CHECK13     036   prom_kypd_5RO_6WO.psm
   COL2_OUT        03A   prom_kypd_5RO_6WO.psm
 * ROW_CHECK20     040   prom_kypd_5RO_6WO.psm
   ROW_CHECK21     046   prom_kypd_5RO_6WO.psm
   ROW_CHECK22     04B   prom_kypd_5RO_6WO.psm
   ROW_CHECK23     050   prom_kypd_5RO_6WO.psm
   COL3_OUT        054   prom_kypd_5RO_6WO.psm
 * ROW_CHECK30     05A   prom_kypd_5RO_6WO.psm
   ROW_CHECK31     060   prom_kypd_5RO_6WO.psm
   ROW_CHECK32     065   prom_kypd_5RO_6WO.psm
   ROW_CHECK33     06A   prom_kypd_5RO_6WO.psm
   DELAY_1MS       06F   prom_kypd_5RO_6WO.psm
   SOFT_DELAY      072   prom_kypd_5RO_6WO.psm
   ROW_CHK_DELAY   078   prom_kypd_5RO_6WO.psm
   READ_ROWS       07C   prom_kypd_5RO_6WO.psm

      * Line label has not been referenced in any instructions.
        Hint - This may indicate unused code that could be
               removed to reduce the size of this program.



Instruction usage statistics

 Instruction    Instances

 LOAD             25
 STAR              -

 AND               -
 OR                3
 XOR               1

 ADD               -
 ADDCY             -
 SUB               2
 SUBCY             2

 TEST              -
 TESTCY            -
 COMPARE          16
 COMPARECY         -

 SL0               3
 SL1               -
 SLX               -
 SLA               -
 RL                -
 SR0               -
 SR1               -
 SRX               -
 SRA               -
 RR                -

 REGBANK           -

 INPUT             5
 OUTPUT           33
 OUTPUTK           -

 STORE             -
 FETCH             -

 DISABLE           -
 ENABLE            -
 RETURNI           -

 JUMP             31
 JUMP@             -
 CALL             12
 CALL@             -
 RETURN            3
 LOAD&RETURN       -

 HWBUILD           -



End of KCPSM6 log file.
